from pyspark.sql.functions import udf, col, broadcast
from pyspark.sql.types import DoubleType
from difflib import SequenceMatcher

# Create a UDF to calculate the Levenshtein distance
def levenshtein_distance(x,y):
  if x is None or y is None:
    return None
  else:
    return SequenceMatcher(None, x, y).ratio()

levenshtein_udf = udf(levenshtein_distance, DoubleType())

from pyspark.sql.functions import coalesce

# Replace null values in columns "Primary_Address_City2" and "place20nm2" with empty strings
dff_regrandcon = dff_regrandcon.withColumn("Primary_Address_City2", coalesce(col("Primary_Address_City2"), F.lit("")))
df2_postalcode = df2_postalcode.withColumn("place20nm2", coalesce(col("place20nm2"), F.lit("")))

# Join the two dataframes on the fuzzy match
similarity_threshold = 0.9
df_joined = dff_regrandcon.alias("df1").join(broadcast(df2_postalcode.alias("df2")), (levenshtein_udf(col("df1.Primary_Address_City2"), col("df2.place20nm2")) > similarity_threshold))

# Select columns from both dataframes and calculate Levenshtein distance
match_data = df_joined.select("df1.registrant_id","df1.Primary_Address_City2","df1.Primary_Address_City","df1.Work_PostalCode","df1.Work_PostalCode2","df1.pcd","df1.pcd2","df2.place20nm","df2.eer20nm","df2.ctry20nm", levenshtein_udf(col("df1.Primary_Address_City2"), col("df2.place20nm2")).alias("levenshtein_distance"))




WITH subquery AS (
  SELECT studentid, studentcourse
  FROM student
  GROUP BY studentid, studentcourse
  HAVING COUNT(*) = 1
)
SELECT studentid, 
       STRING_AGG(studentcourse, ', ') WITHIN GROUP (ORDER BY studentcourse) AS courses
FROM subquery
GROUP BY studentid
HAVING COUNT(*) = 2;












WITH subquery AS (
  SELECT studentid, studentcourse
  FROM student
  GROUP BY studentid, studentcourse
  HAVING COUNT(*) = 1
)
SELECT studentid, 
       STRING_AGG(studentcourse, ', ') WITHIN GROUP (ORDER BY studentcourse) AS courses,
       CASE 
         WHEN COUNT(*) = 2 THEN 'Yes'
         ELSE 'No'
       END AS meeting_condition
FROM subquery
GROUP BY studentid;

















WITH subquery AS (
  SELECT studentid, studentcourse
  FROM student
  GROUP BY studentid, studentcourse
  HAVING COUNT(*) = 1
)
SELECT TOP 10 studentid, 
       STRING_AGG(studentcourse, ', ') WITHIN GROUP (ORDER BY studentcourse) AS courses,
       CASE 
         WHEN COUNT(*) = 2 THEN 'Yes'
         ELSE 'No'
       END AS meeting_condition
FROM subquery
GROUP BY studentid
ORDER BY COUNT(*) DESC;
















WITH subquery AS (
  SELECT studentid, studentcourse
  FROM student
  GROUP BY studentid, studentcourse
  HAVING COUNT(*) = 1
)
SELECT TOP 10 r.request_id, 
       STRING_AGG(s.studentcourse, ', ') WITHIN GROUP (ORDER BY s.studentcourse) AS courses,
       CASE 
         WHEN COUNT(*) = 2 THEN 'Yes'
         ELSE 'No'
       END AS meeting_condition
FROM registration r
LEFT JOIN (
  SELECT studentid, 
         studentcourse
  FROM subquery
  GROUP BY studentid
) s
ON r.studentid = s.studentid
GROUP BY r.request_id, r.studentid
ORDER BY COUNT(*) DESC;









WITH subquery AS (
  SELECT Registrant_ID, 
         Registrant_Name,
         CASE 
           WHEN COUNT(*) = 2 THEN 'Yes'
           ELSE 'No'
         END AS meeting_condition
  FROM (
    SELECT Registrant_ID, Registrant_Name
    FROM registration2
    GROUP BY Registrant_ID, Registrant_Name
    HAVING COUNT(*) = 1
  ) sub
  GROUP BY Registrant_ID
)
SELECT r.Registrant_ID,
       r.Registrant_Name,
       r.active,
       s.registrantdifference,
       s.meeting_condition
FROM registration r
LEFT JOIN (
  SELECT Registrant_ID, 
         STRING_AGG(Registrant_Name, ', ') WITHIN GROUP (ORDER BY Registrant_Name) AS registrantdifference,
         meeting_condition
  FROM subquery
) s
ON r.Registrant_ID = s.Registrant_ID;



WITH subquery AS (
  SELECT Registrant_ID, 
         STRING_AGG(Registration_Name, ', ') WITHIN GROUP (ORDER BY Registration_Name) AS registrantdifference,
         CASE 
           WHEN COUNT(DISTINCT Registration_Name) = 2 THEN 'Yes'
           ELSE 'No'
         END AS meeting_condition
  FROM (
    SELECT Registrant_ID, Registration_Name
    FROM Registration2
    GROUP BY Registrant_ID, Registration_Name
  ) sub
  GROUP BY Registrant_ID
)
SELECT r.Registrant_ID,
       r.Registrant_Name,
       r.active,
       s.registrantdifference,
       s.meeting_condition
FROM registration r
LEFT JOIN subquery s
ON r.Registrant_ID = s.Registrant_ID;






















































WITH subquery AS (
SELECT Registrant_ID,
STRING_AGG(Profession_Name, ', ') WITHIN GROUP (ORDER BY Profession_Name) AS registrantdifference,
CASE
WHEN COUNT(DISTINCT Profession_Name) = 2 THEN 'Yes'
ELSE 'No'
END AS meeting_condition,
CASE
WHEN SUM(CASE WHEN Regsitration_State_Description IN ('inactive', 'blank') THEN 1 ELSE 0 END) = 2 THEN 1
ELSE 0
END AS flag
FROM (
SELECT Registrant_ID,
Profession_Name,
Regsitration_State_Description
FROM [dbo].[registrations]
GROUP BY Registrant_ID,
Profession_Name,
Regsitration_State_Description
) sub
GROUP BY Registrant_ID
)

SELECT Optevia_Contact_ID AS Contact_ID ,
r.Registrant_ID,
r.[Regsitration_State_Description],
r.[Registration_Status_Description],
r.[Profession_Name],
r.[Date_Registered],
r.Registration_Name,
r.[First_Registration_Date] AS [First Registration Date],
r.[Date_Deregistered] AS [Date Deregistered],
r.[Date_Registered] AS [Date most recently registered],
r.[Date_Registered_From] AS [Date registered from],
r.[Date_Registered_To] AS [Date registered to],
s.registrantdifference,
s.meeting_condition AS [ProfessionChange(Yes_No)],
s.flag AS [Flag for Inactive and Blank]
FROM [dbo].[registrations] r
LEFT JOIN subquery s
ON r.Registrant_ID = s.Registrant_ID
Left join [dbo].[contacts] c
ON r.Registrant_ID = c.[Contact_ID]
GROUP BY Optevia_Contact_ID,
r.Registrant_ID,
r.Registration_Name,
r.[Regsitration_State_Description],
r.[Registration_Status_Description],
r.[Profession_Name],
r.[First_Registration_Date],
r.[Date_Registered],
r.[Date_Deregistered],
r.[Date_Registered_From],
r.[Date_Registered_To],
s.registrantdifference,
s.meeting_condition,
s.flag




































WITH subquery AS (
SELECT Registrant_ID,
SUM(CASE WHEN Regsitration_State_Description = 'inactive' THEN 1 ELSE 0 END) +
SUM(CASE WHEN Regsitration_State_Description IS NULL THEN 1 ELSE 0 END) as flag
FROM [dbo].[registrations]
GROUP BY Registrant_ID
HAVING COUNT(DISTINCT Regsitration_State_Description) = 2
)

SELECT Optevia_Contact_ID AS Contact_ID,
r.Registrant_ID,
r.[Regsitration_State_Description],
r.[Registration_Status_Description],
r.[Profession_Name],
r.[Date_Registered],
r.Registration_Name,
r.[First_Registration_Date] AS [First Registration Date],
r.[Date_Deregistered] AS [Date Deregistered],
r.[Date_Registered] AS [Date most recently registered],
r.[Date_Registered_From] AS [Date registered from],
r.[Date_Registered_To] AS [Date registered to],
CASE
WHEN s.flag = 2 THEN 1
ELSE 0
END AS [Flag for Inactive and Null]
FROM [dbo].[registrations] r
LEFT JOIN subquery s
ON r.Registrant_ID = s.Registrant_ID
LEFT JOIN [dbo].[contacts] c
ON r.Registrant_ID = c.[Contact_ID]
GROUP BY Optevia_Contact_ID,
r.Registrant_ID,
r.Registration_Name,
r.[Regsitration_State_Description],
r.[Registration_Status_Description],
r.[Profession_Name],
r.[First_Registration_Date],
r.[Date_Registered],
r.[Date_Deregistered],
r.[Date_Registered_From],
r.[Date_Registered_To],
s.flag












WITH subquery AS (
SELECT Registrant_ID, STRING_AGG(Profession_Name, ', ') WITHIN GROUP (ORDER BY Profession_Name) AS registrantdifference,
CASE WHEN COUNT(DISTINCT Profession_Name) = 2 THEN 'Yes' ELSE 'No' END AS meeting_condition
FROM (
SELECT Registrant_ID, Profession_Name
FROM [dbo].[registrations]
GROUP BY Registrant_ID, Profession_Name
) sub
GROUP BY Registrant_ID
),
new_subquery AS (
SELECT Registrant_ID,
SUM(CASE WHEN [Regsitration_State_Description] = 'inactive' AND [Registration_Status_Description] IS NULL THEN 1 ELSE 0 END) AS flag
FROM [dbo].[registrations]
GROUP BY Registrant_ID
)
SELECT Optevia_Contact_ID AS Contact_ID,
r.Registrant_ID,
r.[Regsitration_State_Description],
r.[Registration_Status_Description],
r.[Profession_Name],
r.[Date_Registered],
r.Registration_Name,
r.[First_Registration_Date] AS [First Registration Date],
r.[Date_Deregistered] AS [Date Deregistered],
r.[Date_Registered] AS [Date most recently registered],
r.[Date_Registered_From] AS [Date registered from],
r.[Date_Registered_To] AS [Date registered to],
--s.registrantdifference,
--s.meeting_condition AS [ProfessionChange(Yes_No)],
n.flag
FROM [dbo].[registrations] r
LEFT JOIN subquery s ON r.Registrant_ID = s.Registrant_ID
LEFT JOIN [dbo].[contacts] c ON r.Registrant_ID = c.[Contact_ID]
LEFT JOIN new_subquery n ON r.Registrant_ID = n.Registrant_ID
GROUP BY Optevia_Contact_ID,
r.Registrant_ID,
r.Registration_Name,
r.[Regsitration_State_Description],
r.[Registration_Status_Description],
r.[Profession_Name],
r.[First_Registration_Date],
r.[Date_Registered],
r.[Date_Deregistered],
r.[Date_Registered_From],
r.[Date_Registered_To],
--s.registrantdifference,
--s.meeting_condition,
n.flag


































WITH subquery AS (
SELECT Registrant_ID,
STRING_AGG(Profession_Name, ', ') WITHIN GROUP (ORDER BY Profession_Name) AS registrantdifference,
CASE WHEN COUNT(DISTINCT Profession_Name) = 2 THEN 'Yes' ELSE 'No' END AS meeting_condition
FROM (
SELECT Registrant_ID, Profession_Name
FROM [dbo].[registrations]
GROUP BY Registrant_ID, Profession_Name
) sub
GROUP BY Registrant_ID
),
status_sum AS (
SELECT Registrant_ID, SUM(StatusCode) OVER (PARTITION BY Registrant_ID) AS total_statuscode
FROM [dbo].[registrations]
)
SELECT top 10
c.Optevia_Contact_ID AS Contact_ID ,
r.Registrant_ID,
r.[Regsitration_State_Description],
r.[Registration_Status_Description],
r.[Profession_Name],
r.[Date_Registered],
r.Registration_Name,
r.[First_Registration_Date] AS [First Registration Date],
r.[Date_Deregistered] AS [Date Deregistered],
r.[Date_Registered] AS [Date most recently registered],
r.[Date_Registered_From] AS [Date registered from],
r.[Date_Registered_To] AS [Date registered to],
s.registrantdifference,
s.meeting_condition AS [ProfessionChange(Yes_No)],
ss.total_statuscode,
CASE WHEN ss.total_statuscode = 3 THEN 1 ELSE 0 END AS new_flag
FROM [dbo].[registrations] r
LEFT JOIN subquery s
ON r.Registrant_ID = s.Registrant_ID
Left join [dbo].[contacts] c
ON r.Registrant_ID = c.[Contact_ID]
LEFT JOIN status_sum ss
ON r.Registrant_ID = ss.Registrant_ID
--where meeting_condition='Yes'
GROUP BY c.Optevia_Contact_ID,
r.Registrant_ID,
r.Registration_Name,
r.[Regsitration_State_Description],
r.[Registration_Status_Description],
r.[Profession_Name],
r.[First_Registration_Date],
r.[Date_Registered],
r.[Date_Deregistered],
r.[Date_Registered_From],
r.[Date_Registered_To],
s.registrantdifference,
s.meeting_condition,
ss.total_statuscode;











































from pyspark.sql.functions import udf, col, broadcast
from pyspark.sql.types import DoubleType
from difflib import SequenceMatcher

# Create a UDF to calculate the Levenshtein distance
def levenshtein_distance(x,y):
  if x is None or y is None:
    return None
  else:
    return SequenceMatcher(None, x, y).ratio()

levenshtein_udf = udf(levenshtein_distance, DoubleType())

from pyspark.sql.functions import coalesce

# Replace null values in columns "Primary_Address_City2" and "place20nm2" with empty strings
dff_regrandcon = dff_regrandcon.withColumn("Primary_Address_City2", coalesce(col("Primary_Address_City2"), F.lit("")))
df2_postalcode = df2_postalcode.withColumn("place20nm2", coalesce(col("place20nm2"), F.lit("")))

# Cache the dataframes for faster processing
dff_regrandcon.cache()
df2_postalcode.cache()

# Repartition the dataframes to minimize data shuffling
dff_regrandcon = dff_regrandcon.repartition(100)
df2_postalcode = df2_postalcode.repartition(100)

# Join the two dataframes on the fuzzy match
similarity_threshold = 0.9
df_joined = dff_regrandcon.alias("df1").join(broadcast(df2_postalcode.alias("df2")), (levenshtein_udf(col("df1.Primary_Address_City2"), col("df2.place20nm2")) > similarity_threshold))

# Select columns from both dataframes and calculate Levenshtein distance
match_data = df_joined.select("df1.registrant_id","df1.Primary_Address_City2","df1.Primary_Address_City","df1.Work_PostalCode","df1.Work_PostalCode2","df1.pcd","df1.pcd2","df2.place20nm","df2.eer20nm","df2.ctry20nm", levenshtein_udf(col("df1.Primary_Address_City2"), col("df2.place20nm2")).alias("levenshtein_distance"))

# Unpersist the dataframes when they are no longer needed
dff_regrandcon.unpersist()
df2_postalcode.unpersist()








Result = df1[M] - 1 + 
    IF(FORMAT(df1[L] - INT(df1[L]), "hh:mm") = "00:00", 
        1, 
        IF(df1[L] - INT(df1[L]) - TIME(10, 0, 0) > TIME(3, 18, 0), 
            1, 
            0.5)
    
    
    )
    
    
    
    
    
    
    
    
    
    df1[Result] = 
    IF(df1[D7] > 0, 
        "Cancelled", 
        IF(df1[L7] = df1[N7], 
            "On time", 
            IF(df1[L7] > df1[N7], 
                "Early", 
                "Later"
            )
        )
    )

    
    
    
    
    
    
    
    
    
    
    
    df1[Result] = 
    IF(df1[D7] > 0, 
        "Cancelled", 
        IF(FORMAT(df1[L7], "hh:mm") = FORMAT(df1[N7], "hh:mm"), 
            "On time", 
            IF(df1[L7] > df1[N7], 
                "Early", 
                "Later"
            )
        )
    )

    
